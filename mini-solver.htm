<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2x2 Rubik's Cube Solver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: #f0f0f0;
        }
        
        .container {
            max-width: 400px;
            width: 100%;
        }
        
        .face-label {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }
        
        .cube-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            gap: 10px;
        }
        
        .cube-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .cube-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
            background: #333;
            padding: 4px;
            width: 300px;
            height: 300px;
        }
        
        .nav-button {
            background: #999999;
            color: white;
            border: 2px solid #333;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: background 0.2s;
            user-select: none;
        }
        
        .nav-button:hover {
            background: #777777;
        }
        
        .nav-button:active {
            background: #666666;
        }
        
        .nav-button-horizontal {
            width: 35px;
            height: 300px;
        }
        
        .nav-button-vertical {
            width: 300px;
            height: 35px;
        }
        
        .nav-spacer {
            width: 35px;
            height: 35px;
        }
        
        .cube-cell {
            aspect-ratio: 1;
            border: 2px solid #333;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .cube-cell:active {
            transform: scale(0.95);
        }
        
        .solution {
            background: white;
            padding: 20px;
            border: 2px solid #333;
            min-height: 100px;
        }
        
        .solution h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .solution-steps {
            font-size: 18px;
            line-height: 1.6;
            color: #666;
        }
        
        .solve-button {
            width: 100%;
            padding: 15px;
            background: #999999;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 20px;
            transition: background 0.2s, opacity 0.2s;
            display: none;
        }
        
        .solve-button.visible {
            display: block;
        }
        
        .solve-button:hover:not(:disabled) {
            background: #777777;
        }
        
        .solve-button:active:not(:disabled) {
            background: #666666;
        }
        
        .solve-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            color: #666666;
        }
        
        .statistics {
            background: white;
            padding: 15px;
            border: 2px solid #333;
            margin-bottom: 20px;
        }
        
        .statistics h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 16px;
        }
        
        .ascii-input {
            width: 100%;
            padding: 8px;
            font-family: monospace;
            font-size: 14px;
            border: 2px solid #333;
            border-radius: 5px;
            box-sizing: border-box;
        }
        
        .ascii-input:focus {
            outline: none;
            border-color: #999999;
        }
        
        .balance-status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .balance-status.balanced {
            background-color: #d4edda;
            color: #155724;
        }
        
        .balance-status.unbalanced {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .balance-status.invalid {
            background-color: #fff3cd;
            color: #856404;
        }
        
        .cube-net {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            margin-bottom: 10px;
        }
        
        .net-row {
            display: flex;
            gap: 2px;
        }
        
        .net-spacer {
            width: 50px;
            height: 50px;
        }
        
        .net-face {
            width: 50px;
            height: 50px;
            border: 2px solid #333;
            position: relative;
            transition: border-color 0.2s, border-width 0.2s;
            cursor: pointer;
        }
        
        .net-face:hover {
            border-color: #4CAF50;
        }
        
        .net-face.active {
            border-color: #ff6b6b;
            border-width: 3px;
        }
        
        .mini-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1px;
            padding: 2px;
            height: calc(100% - 14px);
        }
        
        .mini-cell {
            aspect-ratio: 1;
            border: 1px solid #666;
        }
        
        .net-label {
            position: absolute;
            bottom: 0;
            right: 2px;
            font-size: 10px;
            font-weight: bold;
            color: #333;
        }
        
        .stats-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stat-color {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
        }
        
        .stat-count {
            font-size: 14px;
            color: #333;
        }
        
        .depth-control {
            margin-top: 15px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 5px;
        }
        
        .depth-control label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        
        .depth-slider {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .depth-value {
            text-align: center;
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="face-label" id="faceLabel">Front Face</div>
        
        <div class="cube-container">
            <div class="cube-row">
                <div class="nav-spacer"></div>
                <button class="nav-button nav-button-vertical" id="upBtn">▲</button>
                <div class="nav-spacer"></div>
            </div>
            <div class="cube-row">
                <button class="nav-button nav-button-horizontal" id="leftBtn">◀</button>
                <div class="cube-grid" id="cubeGrid">
                    <div class="cube-cell" data-index="0"></div>
                    <div class="cube-cell" data-index="1"></div>
                    <div class="cube-cell" data-index="2"></div>
                    <div class="cube-cell" data-index="3"></div>
                </div>
                <button class="nav-button nav-button-horizontal" id="rightBtn">▶</button>
            </div>
            <div class="cube-row">
                <div class="nav-spacer"></div>
                <button class="nav-button nav-button-vertical" id="downBtn">▼</button>
                <div class="nav-spacer"></div>
            </div>
        </div>
        
        <div class="statistics" id="statistics">
            <h3>Cube Net:</h3>
            <div class="cube-net">
                <div class="net-row">
                    <div class="net-spacer"></div>
                    <div class="net-face" data-face="4">
                        <div class="mini-grid">
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                        </div>
                        <div class="net-label">U</div>
                    </div>
                </div>
                <div class="net-row">
                    <div class="net-face" data-face="3">
                        <div class="mini-grid">
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                        </div>
                        <div class="net-label">L</div>
                    </div>
                    <div class="net-face" data-face="0">
                        <div class="mini-grid">
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                        </div>
                        <div class="net-label">F</div>
                    </div>
                    <div class="net-face" data-face="1">
                        <div class="mini-grid">
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                        </div>
                        <div class="net-label">R</div>
                    </div>
                    <div class="net-face" data-face="2">
                        <div class="mini-grid">
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                        </div>
                        <div class="net-label">B</div>
                    </div>
                </div>
                <div class="net-row">
                    <div class="net-spacer"></div>
                    <div class="net-face" data-face="5">
                        <div class="mini-grid">
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                        </div>
                        <div class="net-label">D</div>
                    </div>
                </div>
            </div>
            <h3 style="margin-top: 15px;">ASCII Configuration:</h3>
            <input type="text" id="asciiInput" class="ascii-input" placeholder="[w,w,w,w],[o,o,o,o],[y,y,y,y],[r,r,r,r],[b,b,b,b],[g,g,g,g]">
            <h3 style="margin-top: 15px;">Color Count:</h3>
            <div class="stats-grid" id="statsGrid"></div>
            <div class="balance-status" id="balanceStatus"></div>
            
            <div class="depth-control">
                <label for="depthSlider">Maximum Search Depth: <span id="depthValue">14</span></label>
                <input type="range" id="depthSlider" class="depth-slider" min="8" max="20" value="14" step="1">
                <div class="depth-value">Higher depths find more solutions but take longer</div>
            </div>
        </div>
        
        <button class="solve-button" id="solveBtn">Solve Cube</button>
        
        <div class="solution" id="solutionBox" style="display: none;">
            <h3>Solution:</h3>
            <div class="solution-steps" id="solutionSteps">Configure the cube faces, then click "Solve Cube"</div>
        </div>
    </div>

    <script>
        const colors = ['white', 'yellow', 'orange', 'red', 'blue', 'green'];
        const colorLetters = {'white': 'w', 'yellow': 'y', 'orange': 'o', 'red': 'r', 'blue': 'b', 'green': 'g'};
        const letterColors = {'w': 'white', 'y': 'yellow', 'o': 'orange', 'r': 'red', 'b': 'blue', 'g': 'green'};
        const faces = ['Front', 'Right', 'Back', 'Left', 'Up', 'Down'];
        const faceNotation = ['F', 'R', 'B', 'L', 'U', 'D'];
        
        let currentFace = 0;
        let isUpdatingFromInput = false;
        let maxDepth = 14;
        
        // Initialize cube state - each face has 4 cells
        let cube = {
            0: [colors[0], colors[0], colors[0], colors[0]], // Front - white
            1: [colors[2], colors[2], colors[2], colors[2]], // Right - orange
            2: [colors[1], colors[1], colors[1], colors[1]], // Back - yellow
            3: [colors[3], colors[3], colors[3], colors[3]], // Left - red
            4: [colors[4], colors[4], colors[4], colors[4]], // Up - blue
            5: [colors[5], colors[5], colors[5], colors[5]]  // Down - green
        };
        
        // Depth slider
        document.getElementById('depthSlider').addEventListener('input', (e) => {
            maxDepth = parseInt(e.target.value);
            document.getElementById('depthValue').textContent = maxDepth;
        });
        
        function cubeToAscii() {
            const parts = [];
            for (let face = 0; face < 6; face++) {
                const faceLetters = cube[face].map(color => colorLetters[color]);
                parts.push('[' + faceLetters.join(',') + ']');
            }
            return parts.join(',');
        }
        
        function asciiToCube(ascii) {
            try {
                ascii = ascii.replace(/\s/g, '');
                const facePattern = /\[([wyobrg]),([wyobrg]),([wyobrg]),([wyobrg])\]/g;
                const matches = [...ascii.matchAll(facePattern)];
                
                if (matches.length !== 6) {
                    return false;
                }
                
                const newCube = {};
                for (let i = 0; i < 6; i++) {
                    newCube[i] = [
                        letterColors[matches[i][1]],
                        letterColors[matches[i][2]],
                        letterColors[matches[i][3]],
                        letterColors[matches[i][4]]
                    ];
                }
                
                cube = newCube;
                return true;
            } catch (e) {
                return false;
            }
        }
        
        function updateAsciiInput() {
            if (!isUpdatingFromInput) {
                document.getElementById('asciiInput').value = cubeToAscii();
            }
        }
        
        function renderFace() {
            const cells = document.querySelectorAll('.cube-cell');
            cells.forEach((cell, index) => {
                cell.style.backgroundColor = cube[currentFace][index];
            });
            document.getElementById('faceLabel').textContent = faces[currentFace] + ' Face';
            updateStatistics();
            updateAsciiInput();
        }
        
        function updateStatistics() {
            const colorCounts = {};
            colors.forEach(color => colorCounts[color] = 0);
            
            for (let face = 0; face < 6; face++) {
                for (let i = 0; i < 4; i++) {
                    colorCounts[cube[face][i]]++;
                }
            }
            
            document.querySelectorAll('.net-face').forEach(netFace => {
                const faceIndex = parseInt(netFace.dataset.face);
                const miniCells = netFace.querySelectorAll('.mini-cell');
                
                miniCells.forEach((cell, index) => {
                    cell.style.backgroundColor = cube[faceIndex][index];
                });
                
                if (faceIndex === currentFace) {
                    netFace.classList.add('active');
                } else {
                    netFace.classList.remove('active');
                }
            });
            
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = '';
            colors.forEach(color => {
                const statItem = document.createElement('div');
                statItem.className = 'stat-item';
                statItem.innerHTML = `
                    <div class="stat-color" style="background-color: ${color}"></div>
                    <div class="stat-count">${colorCounts[color]}</div>
                `;
                statsGrid.appendChild(statItem);
            });
            
            const isBalanced = colors.every(color => colorCounts[color] === 4);
            const balanceStatus = document.getElementById('balanceStatus');
            
            if (!isBalanced) {
                balanceStatus.className = 'balance-status unbalanced';
                balanceStatus.textContent = '⚠ Colors are not balanced. Each color must appear exactly 4 times.';
            } else {
                balanceStatus.className = 'balance-status balanced';
                balanceStatus.textContent = '✓ Colors are balanced - ready to solve!';
            }
            
            const solveBtn = document.getElementById('solveBtn');
            if (isBalanced) {
                solveBtn.classList.add('visible');
                solveBtn.disabled = false;
            } else {
                solveBtn.classList.remove('visible');
            }
        }
        
        function cycleColor(index) {
            const currentColor = cube[currentFace][index];
            const currentIndex = colors.indexOf(currentColor);
            const nextIndex = (currentIndex + 1) % colors.length;
            cube[currentFace][index] = colors[nextIndex];
            renderFace();
        }
        
        document.querySelectorAll('.cube-cell').forEach(cell => {
            cell.addEventListener('click', () => {
                const index = parseInt(cell.dataset.index);
                cycleColor(index);
            });
        });
        
        document.getElementById('asciiInput').addEventListener('input', (e) => {
            isUpdatingFromInput = true;
            const success = asciiToCube(e.target.value);
            if (success) {
                renderFace();
            }
            isUpdatingFromInput = false;
        });
        
        document.querySelectorAll('.net-face').forEach(netFace => {
            netFace.addEventListener('click', () => {
                currentFace = parseInt(netFace.dataset.face);
                renderFace();
            });
        });
        
        document.getElementById('leftBtn').addEventListener('click', () => {
            if (currentFace === 0) currentFace = 3;
            else if (currentFace === 1) currentFace = 0;
            else if (currentFace === 2) currentFace = 1;
            else if (currentFace === 3) currentFace = 2;
            else if (currentFace === 4) currentFace = 3;
            else if (currentFace === 5) currentFace = 3;
            renderFace();
        });
        
        document.getElementById('rightBtn').addEventListener('click', () => {
            if (currentFace === 0) currentFace = 1;
            else if (currentFace === 1) currentFace = 2;
            else if (currentFace === 2) currentFace = 3;
            else if (currentFace === 3) currentFace = 0;
            else if (currentFace === 4) currentFace = 1;
            else if (currentFace === 5) currentFace = 1;
            renderFace();
        });
        
        document.getElementById('upBtn').addEventListener('click', () => {
            if (currentFace === 0) currentFace = 4;
            else if (currentFace === 1) currentFace = 4;
            else if (currentFace === 2) currentFace = 4;
            else if (currentFace === 3) currentFace = 4;
            else if (currentFace === 4) currentFace = 2;
            else if (currentFace === 5) currentFace = 0;
            renderFace();
        });
        
        document.getElementById('downBtn').addEventListener('click', () => {
            if (currentFace === 0) currentFace = 5;
            else if (currentFace === 1) currentFace = 5;
            else if (currentFace === 2) currentFace = 5;
            else if (currentFace === 3) currentFace = 5;
            else if (currentFace === 4) currentFace = 0;
            else if (currentFace === 5) currentFace = 2;
            renderFace();
        });
        
        // IMPROVED SOLVER - Iterative Deepening DFS with move pruning
        document.getElementById('solveBtn').addEventListener('click', () => {
            document.getElementById('solutionBox').style.display = 'block';
            document.getElementById('solutionSteps').textContent = "Solving...";
            document.getElementById('solveBtn').disabled = true;
            
            setTimeout(() => {
                const solution = solveCube();
                document.getElementById('solutionSteps').textContent = solution;
                document.getElementById('solveBtn').disabled = false;
            }, 100);
        });
        
        function getCubeState(cubeState) {
            return JSON.stringify(cubeState);
        }
        
        function isSolved(cubeState) {
            for (let face = 0; face < 6; face++) {
                const firstColor = cubeState[face][0];
                for (let i = 1; i < 4; i++) {
                    if (cubeState[face][i] !== firstColor) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        function solveCube() {
            if (isSolved(cube)) {
                return "Cube is already solved!";
            }
            
            // Use Iterative Deepening Depth-First Search (IDDFS)
            // This is optimal and memory efficient
            const moves = ['F', 'R', 'U', "F'", "R'", "U'", 'F2', 'R2', 'U2'];
            
            for (let depth = 1; depth <= maxDepth; depth++) {
                const startTime = Date.now();
                const result = iddfs(cube, moves, depth, null);
                
                if (result) {
                    return `${result} (${result.split(' ').length} moves, depth ${depth})`;
                }
                
                // Safety timeout check
                if (Date.now() - startTime > 5000) {
                    return `Search timeout at depth ${depth}. Try increasing max depth or the cube may require a longer solution.`;
                }
            }
            
            return `No solution found within depth ${maxDepth}. Try increasing the maximum depth.`;
        }
        
        function iddfs(cubeState, moves, maxDepth, lastMove) {
            return dfs(cubeState, moves, maxDepth, 0, [], lastMove);
        }
        
        function dfs(cubeState, moves, maxDepth, currentDepth, path, lastMove) {
            if (isSolved(cubeState)) {
                return path.join(' ');
            }
            
            if (currentDepth >= maxDepth) {
                return null;
            }
            
            for (const move of moves) {
                // Pruning: don't do the same face twice in a row
                if (lastMove && move[0] === lastMove[0]) {
                    continue;
                }
                
                // Pruning: don't do opposite faces back-to-back in canonical order
                // This prevents redundant sequences like F B F
                if (lastMove) {
                    const lastFace = lastMove[0];
                    const currentFace = move[0];
                    
                    // Define opposite face pairs where we enforce order
                    if ((lastFace === 'F' && currentFace === 'B') ||
                        (lastFace === 'R' && currentFace === 'L') ||
                        (lastFace === 'U' && currentFace === 'D')) {
                        continue;
                    }
                }
                
                const newState = JSON.parse(JSON.stringify(cubeState));
                performMove(newState, move);
                
                const result = dfs(newState, moves, maxDepth, currentDepth + 1, [...path, move], move);
                if (result) {
                    return result;
                }
            }
            
            return null;
        }
        
        function rotateFace(cubeState, face, clockwise = true) {
            const f = cubeState[face];
            if (clockwise) {
                cubeState[face] = [f[2], f[0], f[3], f[1]];
            } else {
                cubeState[face] = [f[1], f[3], f[0], f[2]];
            }
            
            let temp;
            if (face === 0) { // Front
                temp = [cubeState[4][2], cubeState[4][3]];
                if (clockwise) {
                    cubeState[4][2] = cubeState[3][3];
                    cubeState[4][3] = cubeState[3][1];
                    cubeState[3][3] = cubeState[5][1];
                    cubeState[3][1] = cubeState[5][0];
                    cubeState[5][1] = cubeState[1][0];
                    cubeState[5][0] = cubeState[1][2];
                    cubeState[1][0] = temp[0];
                    cubeState[1][2] = temp[1];
                } else {
                    cubeState[4][2] = cubeState[1][0];
                    cubeState[4][3] = cubeState[1][2];
                    cubeState[1][0] = cubeState[5][1];
                    cubeState[1][2] = cubeState[5][0];
                    cubeState[5][1] = cubeState[3][3];
                    cubeState[5][0] = cubeState[3][1];
                    cubeState[3][3] = temp[0];
                    cubeState[3][1] = temp[1];
                }
            } else if (face === 1) { // Right
                temp = [cubeState[4][1], cubeState[4][3]];
                if (clockwise) {
                    cubeState[4][1] = cubeState[0][1];
                    cubeState[4][3] = cubeState[0][3];
                    cubeState[0][1] = cubeState[5][1];
                    cubeState[0][3] = cubeState[5][3];
                    cubeState[5][1] = cubeState[2][2];
                    cubeState[5][3] = cubeState[2][0];
                    cubeState[2][2] = temp[0];
                    cubeState[2][0] = temp[1];
                } else {
                    cubeState[4][1] = cubeState[2][2];
                    cubeState[4][3] = cubeState[2][0];
                    cubeState[2][2] = cubeState[5][1];
                    cubeState[2][0] = cubeState[5][3];
                    cubeState[5][1] = cubeState[0][1];
                    cubeState[5][3] = cubeState[0][3];
                    cubeState[0][1] = temp[0];
                    cubeState[0][3] = temp[1];
                }
            } else if (face === 2) { // Back
                temp = [cubeState[4][0], cubeState[4][1]];
                if (clockwise) {
                    cubeState[4][0] = cubeState[1][1];
                    cubeState[4][1] = cubeState[1][3];
                    cubeState[1][1] = cubeState[5][3];
                    cubeState[1][3] = cubeState[5][2];
                    cubeState[5][3] = cubeState[3][2];
                    cubeState[5][2] = cubeState[3][0];
                    cubeState[3][2] = temp[0];
                    cubeState[3][0] = temp[1];
                } else {
                    cubeState[4][0] = cubeState[3][2];
                    cubeState[4][1] = cubeState[3][0];
                    cubeState[3][2] = cubeState[5][3];
                    cubeState[3][0] = cubeState[5][2];
                    cubeState[5][3] = cubeState[1][1];
                    cubeState[5][2] = cubeState[1][3];
                    cubeState[1][1] = temp[0];
                    cubeState[1][3] = temp[1];
                }
            } else if (face === 3) { // Left
                temp = [cubeState[4][0], cubeState[4][2]];
                if (clockwise) {
                    cubeState[4][0] = cubeState[2][3];
                    cubeState[4][2] = cubeState[2][1];
                    cubeState[2][3] = cubeState[5][0];
                    cubeState[2][1] = cubeState[5][2];
                    cubeState[5][0] = cubeState[0][0];
                    cubeState[5][2] = cubeState[0][2];
                    cubeState[0][0] = temp[0];
                    cubeState[0][2] = temp[1];
                } else {
                    cubeState[4][0] = cubeState[0][0];
                    cubeState[4][2] = cubeState[0][2];
                    cubeState[0][0] = cubeState[5][0];
                    cubeState[0][2] = cubeState[5][2];
                    cubeState[5][0] = cubeState[2][3];
                    cubeState[5][2] = cubeState[2][1];
                    cubeState[2][3] = temp[0];
                    cubeState[2][1] = temp[1];
                }
            } else if (face === 4) { // Up
                temp = [cubeState[0][0], cubeState[0][1]];
                if (clockwise) {
                    cubeState[0][0] = cubeState[1][0];
                    cubeState[0][1] = cubeState[1][1];
                    cubeState[1][0] = cubeState[2][0];
                    cubeState[1][1] = cubeState[2][1];
                    cubeState[2][0] = cubeState[3][0];
                    cubeState[2][1] = cubeState[3][1];
                    cubeState[3][0] = temp[0];
                    cubeState[3][1] = temp[1];
                } else {
                    cubeState[0][0] = cubeState[3][0];
                    cubeState[0][1] = cubeState[3][1];
                    cubeState[3][0] = cubeState[2][0];
                    cubeState[3][1] = cubeState[2][1];
                    cubeState[2][0] = cubeState[1][0];
                    cubeState[2][1] = cubeState[1][1];
                    cubeState[1][0] = temp[0];
                    cubeState[1][1] = temp[1];
                }
            } else if (face === 5) { // Down
                temp = [cubeState[0][2], cubeState[0][3]];
                if (clockwise) {
                    cubeState[0][2] = cubeState[3][2];
                    cubeState[0][3] = cubeState[3][3];
                    cubeState[3][2] = cubeState[2][2];
                    cubeState[3][3] = cubeState[2][3];
                    cubeState[2][2] = cubeState[1][2];
                    cubeState[2][3] = cubeState[1][3];
                    cubeState[1][2] = temp[0];
                    cubeState[1][3] = temp[1];
                } else {
                    cubeState[0][2] = cubeState[1][2];
                    cubeState[0][3] = cubeState[1][3];
                    cubeState[1][2] = cubeState[2][2];
                    cubeState[1][3] = cubeState[2][3];
                    cubeState[2][2] = cubeState[3][2];
                    cubeState[2][3] = cubeState[3][3];
                    cubeState[3][2] = temp[0];
                    cubeState[3][3] = temp[1];
                }
            }
        }
        
        function performMove(cubeState, move) {
            const faceMap = {'F': 0, 'R': 1, 'B': 2, 'L': 3, 'U': 4, 'D': 5};
            const isPrime = move.includes("'");
            const isDouble = move.includes("2");
            const faceLetter = move[0];
            const faceIndex = faceMap[faceLetter];
            
            if (isDouble) {
                rotateFace(cubeState, faceIndex, true);
                rotateFace(cubeState, faceIndex, true);
            } else {
                rotateFace(cubeState, faceIndex, !isPrime);
            }
        }
        
        renderFace();
        updateAsciiInput();
    </script>
</body>
</html>
