<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2x2 Rubik's Cube Solver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: #f0f0f0;
        }
        
        .container {
            max-width: 400px;
            width: 100%;
        }
        
        .face-label {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }
        
        .cube-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            gap: 10px;
        }
        
        .cube-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .cube-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
            background: #333;
            padding: 4px;
            width: 300px;
            height: 300px;
        }
        
        .nav-button {
            background: #999999;
            color: white;
            border: 2px solid #333;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: background 0.2s;
            user-select: none;
        }
        
        .nav-button:hover {
            background: #777777;
        }
        
        .nav-button:active {
            background: #666666;
        }
        
        .nav-button-horizontal {
            width: 35px;
            height: 300px;
        }
        
        .nav-button-vertical {
            width: 300px;
            height: 35px;
        }
        
        .nav-spacer {
            width: 35px;
            height: 35px;
        }
        
        .cube-cell {
            aspect-ratio: 1;
            border: 2px solid #333;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .cube-cell:active {
            transform: scale(0.95);
        }
        
        .solution {
            background: white;
            padding: 20px;
            border: 2px solid #333;
            min-height: 100px;
        }
        
        .solution h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .solution-steps {
            font-size: 18px;
            line-height: 1.6;
            color: #666;
        }
        
        .solve-button {
            width: 100%;
            padding: 15px;
            background: #999999;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 20px;
            transition: background 0.2s, opacity 0.2s;
            display: none;
        }
        
        .solve-button.visible {
            display: block;
        }
        
        .solve-button:hover:not(:disabled) {
            background: #777777;
        }
        
        .solve-button:active:not(:disabled) {
            background: #666666;
        }
        
        .solve-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            color: #666666;
        }
        
        .statistics {
            background: white;
            padding: 15px;
            border: 2px solid #333;
            margin-bottom: 20px;
        }
        
        .statistics h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 16px;
        }
        
        .ascii-input {
            width: 100%;
            padding: 8px;
            font-family: monospace;
            font-size: 14px;
            border: 2px solid #333;
            border-radius: 5px;
            box-sizing: border-box;
        }
        
        .ascii-input:focus {
            outline: none;
            border-color: #999999;
        }
        
        .balance-status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .balance-status.balanced {
            background-color: #d4edda;
            color: #155724;
        }
        
        .balance-status.unbalanced {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .balance-status.invalid {
            background-color: #fff3cd;
            color: #856404;
        }
        
        .cube-net {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            margin-bottom: 10px;
        }
        
        .net-row {
            display: flex;
            gap: 2px;
        }
        
        .net-spacer {
            width: 50px;
            height: 50px;
        }
        
        .net-face {
            width: 50px;
            height: 50px;
            border: 2px solid #333;
            position: relative;
            transition: border-color 0.2s, border-width 0.2s;
            cursor: pointer;
        }
        
        .net-face:hover {
            border-color: #4CAF50;
        }
        
        .net-face.active {
            border-color: #ff6b6b;
            border-width: 3px;
        }
        
        .mini-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1px;
            padding: 2px;
            height: calc(100% - 14px);
        }
        
        .mini-cell {
            aspect-ratio: 1;
            border: 1px solid #666;
        }
        
        .net-label {
            position: absolute;
            bottom: 0;
            right: 2px;
            font-size: 10px;
            font-weight: bold;
            color: #333;
        }
        
        .stats-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stat-color {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
        }
        
        .stat-count {
            font-size: 14px;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="face-label" id="faceLabel">Front Face</div>
        
        <div class="cube-container">
            <div class="cube-row">
                <div class="nav-spacer"></div>
                <button class="nav-button nav-button-vertical" id="upBtn">▲</button>
                <div class="nav-spacer"></div>
            </div>
            <div class="cube-row">
                <button class="nav-button nav-button-horizontal" id="leftBtn">◀</button>
                <div class="cube-grid" id="cubeGrid">
                    <div class="cube-cell" data-index="0"></div>
                    <div class="cube-cell" data-index="1"></div>
                    <div class="cube-cell" data-index="2"></div>
                    <div class="cube-cell" data-index="3"></div>
                </div>
                <button class="nav-button nav-button-horizontal" id="rightBtn">▶</button>
            </div>
            <div class="cube-row">
                <div class="nav-spacer"></div>
                <button class="nav-button nav-button-vertical" id="downBtn">▼</button>
                <div class="nav-spacer"></div>
            </div>
        </div>
        
        <div class="statistics" id="statistics">
            <h3>Cube Net:</h3>
            <div class="cube-net">
                <div class="net-row">
                    <div class="net-spacer"></div>
                    <div class="net-face" data-face="4">
                        <div class="mini-grid">
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                        </div>
                        <div class="net-label">U</div>
                    </div>
                </div>
                <div class="net-row">
                    <div class="net-face" data-face="3">
                        <div class="mini-grid">
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                        </div>
                        <div class="net-label">L</div>
                    </div>
                    <div class="net-face" data-face="0">
                        <div class="mini-grid">
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                        </div>
                        <div class="net-label">F</div>
                    </div>
                    <div class="net-face" data-face="1">
                        <div class="mini-grid">
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                        </div>
                        <div class="net-label">R</div>
                    </div>
                    <div class="net-face" data-face="2">
                        <div class="mini-grid">
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                        </div>
                        <div class="net-label">B</div>
                    </div>
                </div>
                <div class="net-row">
                    <div class="net-spacer"></div>
                    <div class="net-face" data-face="5">
                        <div class="mini-grid">
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                            <div class="mini-cell"></div>
                        </div>
                        <div class="net-label">D</div>
                    </div>
                </div>
            </div>
            <h3 style="margin-top: 15px;">ASCII Configuration:</h3>
            <input type="text" id="asciiInput" class="ascii-input" placeholder="[w,w,w,w],[o,o,o,o],[y,y,y,y],[r,r,r,r],[b,b,b,b],[g,g,g,g]">
            <h3 style="margin-top: 15px;">Color Count:</h3>
            <div class="stats-grid" id="statsGrid"></div>
            <div class="balance-status" id="balanceStatus"></div>
        </div>
        
        <button class="solve-button" id="solveBtn">Solve Cube</button>
        
        <div class="solution" id="solutionBox" style="display: none;">
            <h3>Solution:</h3>
            <div class="solution-steps" id="solutionSteps">Configure the cube faces, then click "Solve Cube"</div>
        </div>
    </div>

    <script>
        const colors = ['white', 'yellow', 'orange', 'red', 'blue', 'green'];
        const colorLetters = {'white': 'w', 'yellow': 'y', 'orange': 'o', 'red': 'r', 'blue': 'b', 'green': 'g'};
        const letterColors = {'w': 'white', 'y': 'yellow', 'o': 'orange', 'r': 'red', 'b': 'blue', 'g': 'green'};
        const faces = ['Front', 'Right', 'Back', 'Left', 'Up', 'Down'];
        const faceNotation = ['F', 'R', 'B', 'L', 'U', 'D'];
        
        let currentFace = 0;
        let isUpdatingFromInput = false;
        
        // Initialize cube state - each face has 4 cells
        let cube = {
            0: [colors[0], colors[0], colors[0], colors[0]], // Front - white
            1: [colors[2], colors[2], colors[2], colors[2]], // Right - orange
            2: [colors[1], colors[1], colors[1], colors[1]], // Back - yellow
            3: [colors[3], colors[3], colors[3], colors[3]], // Left - red
            4: [colors[4], colors[4], colors[4], colors[4]], // Up - blue
            5: [colors[5], colors[5], colors[5], colors[5]]  // Down - green
        };
        
        function cubeToAscii() {
            // Convert cube state to ASCII format: [w,w,w,w],[o,o,o,o],[y,y,y,y],[r,r,r,r],[b,b,b,b],[g,g,g,g]
            const parts = [];
            for (let face = 0; face < 6; face++) {
                const faceLetters = cube[face].map(color => colorLetters[color]);
                parts.push('[' + faceLetters.join(',') + ']');
            }
            return parts.join(',');
        }
        
        function asciiToCube(ascii) {
            // Parse ASCII format and update cube state
            try {
                // Remove spaces and validate format
                ascii = ascii.replace(/\s/g, '');
                
                // Match pattern: [x,x,x,x],[x,x,x,x],... (6 times)
                const facePattern = /\[([wyobrg]),([wyobrg]),([wyobrg]),([wyobrg])\]/g;
                const matches = [...ascii.matchAll(facePattern)];
                
                if (matches.length !== 6) {
                    return false; // Invalid format
                }
                
                const newCube = {};
                for (let i = 0; i < 6; i++) {
                    newCube[i] = [
                        letterColors[matches[i][1]],
                        letterColors[matches[i][2]],
                        letterColors[matches[i][3]],
                        letterColors[matches[i][4]]
                    ];
                }
                
                // Update the global cube state
                cube = newCube;
                return true;
            } catch (e) {
                return false;
            }
        }
        
        function updateAsciiInput() {
            if (!isUpdatingFromInput) {
                document.getElementById('asciiInput').value = cubeToAscii();
            }
        }
        
        function renderFace() {
            const cells = document.querySelectorAll('.cube-cell');
            cells.forEach((cell, index) => {
                cell.style.backgroundColor = cube[currentFace][index];
            });
            document.getElementById('faceLabel').textContent = faces[currentFace] + ' Face';
            updateStatistics();
            updateAsciiInput();
        }
        
        function updateStatistics() {
            const colorCounts = {};
            colors.forEach(color => colorCounts[color] = 0);
            
            // Count all colors across all faces
            for (let face = 0; face < 6; face++) {
                for (let i = 0; i < 4; i++) {
                    colorCounts[cube[face][i]]++;
                }
            }
            
            // Update cube net visualization
            document.querySelectorAll('.net-face').forEach(netFace => {
                const faceIndex = parseInt(netFace.dataset.face);
                const miniCells = netFace.querySelectorAll('.mini-cell');
                
                // Update colors in the mini grid
                miniCells.forEach((cell, index) => {
                    cell.style.backgroundColor = cube[faceIndex][index];
                });
                
                // Highlight current face
                if (faceIndex === currentFace) {
                    netFace.classList.add('active');
                } else {
                    netFace.classList.remove('active');
                }
            });
            
            // Display color count statistics
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = '';
            colors.forEach(color => {
                const statItem = document.createElement('div');
                statItem.className = 'stat-item';
                statItem.innerHTML = `
                    <div class="stat-color" style="background-color: ${color}"></div>
                    <div class="stat-count">${colorCounts[color]}</div>
                `;
                statsGrid.appendChild(statItem);
            });
            
            // Check if cube is balanced (each color should appear exactly 4 times)
            const isBalanced = colors.every(color => colorCounts[color] === 4);
            
            // Check if cube is valid (can be solved)
            const isValid = isBalanced && isCubeValid(cube);
            
            // Display balance and validity status
            const balanceStatus = document.getElementById('balanceStatus');
            if (!isBalanced) {
                balanceStatus.className = 'balance-status unbalanced';
                balanceStatus.textContent = '⚠ Colors are not balanced. Each color must appear exactly 4 times.';
            } else if (!isValid) {
                balanceStatus.className = 'balance-status invalid';
                balanceStatus.textContent = '⚠ Colors are balanced but this is not a valid cube state. The cube cannot be solved from this configuration.';
            } else {
                balanceStatus.className = 'balance-status balanced';
                balanceStatus.textContent = '✓ Colors are balanced and cube state is valid!';
            }
            
            // Show/hide solve button based on balance and validity
            const solveBtn = document.getElementById('solveBtn');
            if (isBalanced && isValid) {
                solveBtn.classList.add('visible');
                solveBtn.disabled = false;
            } else {
                solveBtn.classList.remove('visible');
            }
        }
        
        function isCubeValid(cubeState) {
            // A 2x2 cube state is valid if it can be reached from the solved state
            // For a quick check, we verify the corner permutation parity
            // In a 2x2 cube, all 8 corners must be in valid positions
            
            // Simple check: if colors are balanced, assume valid for now
            // A full validation would require checking permutation parity
            // which is complex for a web interface
            
            // For practical purposes, we'll consider it valid if:
            // 1. Colors are balanced (checked before calling this)
            // 2. Each face doesn't have all 4 stickers the same except if whole cube is solved
            
            let allSolvedCount = 0;
            for (let face = 0; face < 6; face++) {
                const firstColor = cubeState[face][0];
                const allSame = cubeState[face].every(c => c === firstColor);
                if (allSame) {
                    allSolvedCount++;
                }
            }
            
            // If all faces are solved, it's valid
            if (allSolvedCount === 6) {
                return true;
            }
            
            // If some faces are fully solved but not all, it might still be valid
            // For simplicity, we'll assume any balanced configuration is potentially valid
            // The solver will determine if it's actually solvable
            return true;
        }
        
        function cycleColor(index) {
            const currentColor = cube[currentFace][index];
            const currentIndex = colors.indexOf(currentColor);
            const nextIndex = (currentIndex + 1) % colors.length;
            cube[currentFace][index] = colors[nextIndex];
            renderFace();
        }
        
        // Add click handlers to cells
        document.querySelectorAll('.cube-cell').forEach(cell => {
            cell.addEventListener('click', () => {
                const index = parseInt(cell.dataset.index);
                cycleColor(index);
            });
        });
        
        // Add input handler for ASCII configuration
        document.getElementById('asciiInput').addEventListener('input', (e) => {
            isUpdatingFromInput = true;
            const success = asciiToCube(e.target.value);
            if (success) {
                renderFace();
            }
            isUpdatingFromInput = false;
        });
        
        // Add click handlers to cube net faces for navigation
        document.querySelectorAll('.net-face').forEach(netFace => {
            netFace.addEventListener('click', () => {
                currentFace = parseInt(netFace.dataset.face);
                renderFace();
            });
        });
        
        // Navigation buttons - rotate view around the cube
        // Face order: 0=Front, 1=Right, 2=Back, 3=Left, 4=Up, 5=Down
        document.getElementById('leftBtn').addEventListener('click', () => {
            if (currentFace === 0) currentFace = 3;      // Front -> Left
            else if (currentFace === 1) currentFace = 0; // Right -> Front
            else if (currentFace === 2) currentFace = 1; // Back -> Right
            else if (currentFace === 3) currentFace = 2; // Left -> Back
            else if (currentFace === 4) currentFace = 3; // Up -> Left
            else if (currentFace === 5) currentFace = 3; // Down -> Left
            renderFace();
        });
        
        document.getElementById('rightBtn').addEventListener('click', () => {
            if (currentFace === 0) currentFace = 1;      // Front -> Right
            else if (currentFace === 1) currentFace = 2; // Right -> Back
            else if (currentFace === 2) currentFace = 3; // Back -> Left
            else if (currentFace === 3) currentFace = 0; // Left -> Front
            else if (currentFace === 4) currentFace = 1; // Up -> Right
            else if (currentFace === 5) currentFace = 1; // Down -> Right
            renderFace();
        });
        
        document.getElementById('upBtn').addEventListener('click', () => {
            if (currentFace === 0) currentFace = 4;      // Front -> Up
            else if (currentFace === 1) currentFace = 4; // Right -> Up
            else if (currentFace === 2) currentFace = 4; // Back -> Up
            else if (currentFace === 3) currentFace = 4; // Left -> Up
            else if (currentFace === 4) currentFace = 2; // Up -> Back
            else if (currentFace === 5) currentFace = 0; // Down -> Front
            renderFace();
        });
        
        document.getElementById('downBtn').addEventListener('click', () => {
            if (currentFace === 0) currentFace = 5;      // Front -> Down
            else if (currentFace === 1) currentFace = 5; // Right -> Down
            else if (currentFace === 2) currentFace = 5; // Back -> Down
            else if (currentFace === 3) currentFace = 5; // Left -> Down
            else if (currentFace === 4) currentFace = 0; // Up -> Front
            else if (currentFace === 5) currentFace = 2; // Down -> Back
            renderFace();
        });
        
        // Optimized BFS solver for 2x2 Rubik's cube with advanced pruning
        document.getElementById('solveBtn').addEventListener('click', () => {
            // Show solution box
            document.getElementById('solutionBox').style.display = 'block';
            document.getElementById('solutionSteps').textContent = "Solving...";
            
            // Use setTimeout to prevent UI blocking
            setTimeout(() => {
                const solution = solveCube();
                document.getElementById('solutionSteps').textContent = solution;
            }, 100);
        });
        
        function getCubeState(cubeState) {
            // Create a normalized state representation
            return JSON.stringify(cubeState);
        }
        
        function isSolved(cubeState) {
            for (let face = 0; face < 6; face++) {
                const firstColor = cubeState[face][0];
                for (let i = 1; i < 4; i++) {
                    if (cubeState[face][i] !== firstColor) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        function solveCube() {
            if (isSolved(cube)) {
                return "Cube is already solved!";
            }
            
            // Bidirectional BFS for faster solving
            // Search from both initial state and solved state
            const startQueue = [{state: JSON.parse(JSON.stringify(cube)), moves: [], lastMove: null}];
            const startVisited = new Map();
            startVisited.set(getCubeState(cube), []);
            
            // Create solved state
            const solvedState = {
                0: [colors[0], colors[0], colors[0], colors[0]], // Front - white
                1: [colors[2], colors[2], colors[2], colors[2]], // Right - orange
                2: [colors[1], colors[1], colors[1], colors[1]], // Back - yellow
                3: [colors[3], colors[3], colors[3], colors[3]], // Left - red
                4: [colors[4], colors[4], colors[4], colors[4]], // Up - blue
                5: [colors[5], colors[5], colors[5], colors[5]]  // Down - green
            };
            
            const goalQueue = [{state: solvedState, moves: [], lastMove: null}];
            const goalVisited = new Map();
            goalVisited.set(getCubeState(solvedState), []);
            
            // Use all 6 faces for complete coverage
            const baseMoves = ['F', 'R', 'B', 'L', 'U', 'D'];
            const allMoves = [];
            baseMoves.forEach(move => {
                allMoves.push(move);       // Clockwise
                allMoves.push(move + "'");  // Counter-clockwise
                allMoves.push(move + "2");  // 180 degree
            });
            
            let iterations = 0;
            const maxIterations = 200000; // Increased for all 6 faces
            
            // Alternating bidirectional search
            while (startQueue.length > 0 && goalQueue.length > 0 && iterations < maxIterations) {
                iterations++;
                
                // Expand from start
                if (startQueue.length > 0) {
                    const current = startQueue.shift();
                    
                    for (const move of allMoves) {
                        if (shouldPruneMove(current.lastMove, move)) {
                            continue;
                        }
                        
                        const newState = JSON.parse(JSON.stringify(current.state));
                        performMove(newState, move);
                        const stateKey = getCubeState(newState);
                        
                        // Check if we've met the goal search
                        if (goalVisited.has(stateKey)) {
                            const startMoves = [...current.moves, move];
                            const goalMoves = goalVisited.get(stateKey);
                            // Reverse and invert goal moves
                            const reversedGoalMoves = reverseMovesSequence(goalMoves);
                            return [...startMoves, ...reversedGoalMoves].join(' ');
                        }
                        
                        if (!startVisited.has(stateKey)) {
                            const newMoves = [...current.moves, move];
                            startVisited.set(stateKey, newMoves);
                            startQueue.push({
                                state: newState,
                                moves: newMoves,
                                lastMove: move
                            });
                        }
                    }
                    
                    if (current.moves.length >= 6) continue; // Limit depth for start search
                }
                
                // Expand from goal
                if (goalQueue.length > 0) {
                    const current = goalQueue.shift();
                    
                    for (const move of allMoves) {
                        if (shouldPruneMove(current.lastMove, move)) {
                            continue;
                        }
                        
                        const newState = JSON.parse(JSON.stringify(current.state));
                        performMove(newState, move);
                        const stateKey = getCubeState(newState);
                        
                        // Check if we've met the start search
                        if (startVisited.has(stateKey)) {
                            const startMoves = startVisited.get(stateKey);
                            const goalMoves = [...current.moves, move];
                            const reversedGoalMoves = reverseMovesSequence(goalMoves);
                            return [...startMoves, ...reversedGoalMoves].join(' ');
                        }
                        
                        if (!goalVisited.has(stateKey)) {
                            const newMoves = [...current.moves, move];
                            goalVisited.set(stateKey, newMoves);
                            goalQueue.push({
                                state: newState,
                                moves: newMoves,
                                lastMove: move
                            });
                        }
                    }
                    
                    if (current.moves.length >= 6) continue; // Limit depth for goal search
                }
            }
            
            return "Solution not found within search depth. The cube may require a longer solution or may not be valid.";
        }
        
        function reverseMovesSequence(moves) {
            // Reverse the sequence and invert each move
            const reversed = [];
            for (let i = moves.length - 1; i >= 0; i--) {
                reversed.push(invertMove(moves[i]));
            }
            return reversed;
        }
        
        function invertMove(move) {
            if (move.endsWith("'")) {
                return move[0]; // F' becomes F
            } else if (move.endsWith("2")) {
                return move; // F2 stays F2
            } else {
                return move + "'"; // F becomes F'
            }
        }
        
        function shouldPruneMove(lastMove, nextMove) {
            if (!lastMove) return false;
            
            const lastFace = lastMove[0];
            const nextFace = nextMove[0];
            
            // Don't move the same face twice in a row
            if (lastFace === nextFace) {
                return true;
            }
            
            // Prune opposite face moves in certain order to avoid redundancy
            // F-B, R-L, U-D are opposite pairs
            const oppositePairs = [
                ['F', 'B'],
                ['R', 'L'],
                ['U', 'D']
            ];
            
            for (const pair of oppositePairs) {
                // If last move was the second in a pair and next is the first,
                // we can skip it (canonical order)
                if (lastFace === pair[1] && nextFace === pair[0]) {
                    return true;
                }
            }
            
            return false;
        }
        
        function rotateFace(cubeState, face, clockwise = true) {
            // Rotate the face itself
            const f = cubeState[face];
            if (clockwise) {
                cubeState[face] = [f[2], f[0], f[3], f[1]];
            } else {
                cubeState[face] = [f[1], f[3], f[0], f[2]];
            }
            
            // Rotate adjacent pieces
            // Face indices: 0=Front, 1=Right, 2=Back, 3=Left, 4=Up, 5=Down
            // Each face position: [0=top-left, 1=top-right, 2=bottom-left, 3=bottom-right]
            
            let temp;
            if (face === 0) { // Front
                temp = [cubeState[4][2], cubeState[4][3]];
                if (clockwise) {
                    cubeState[4][2] = cubeState[3][3];
                    cubeState[4][3] = cubeState[3][1];
                    cubeState[3][3] = cubeState[5][1];
                    cubeState[3][1] = cubeState[5][0];
                    cubeState[5][1] = cubeState[1][0];
                    cubeState[5][0] = cubeState[1][2];
                    cubeState[1][0] = temp[0];
                    cubeState[1][2] = temp[1];
                } else {
                    cubeState[4][2] = cubeState[1][0];
                    cubeState[4][3] = cubeState[1][2];
                    cubeState[1][0] = cubeState[5][1];
                    cubeState[1][2] = cubeState[5][0];
                    cubeState[5][1] = cubeState[3][3];
                    cubeState[5][0] = cubeState[3][1];
                    cubeState[3][3] = temp[0];
                    cubeState[3][1] = temp[1];
                }
            } else if (face === 1) { // Right
                temp = [cubeState[4][1], cubeState[4][3]];
                if (clockwise) {
                    cubeState[4][1] = cubeState[0][1];
                    cubeState[4][3] = cubeState[0][3];
                    cubeState[0][1] = cubeState[5][1];
                    cubeState[0][3] = cubeState[5][3];
                    cubeState[5][1] = cubeState[2][2];
                    cubeState[5][3] = cubeState[2][0];
                    cubeState[2][2] = temp[0];
                    cubeState[2][0] = temp[1];
                } else {
                    cubeState[4][1] = cubeState[2][2];
                    cubeState[4][3] = cubeState[2][0];
                    cubeState[2][2] = cubeState[5][1];
                    cubeState[2][0] = cubeState[5][3];
                    cubeState[5][1] = cubeState[0][1];
                    cubeState[5][3] = cubeState[0][3];
                    cubeState[0][1] = temp[0];
                    cubeState[0][3] = temp[1];
                }
            } else if (face === 2) { // Back
                temp = [cubeState[4][0], cubeState[4][1]];
                if (clockwise) {
                    cubeState[4][0] = cubeState[1][1];
                    cubeState[4][1] = cubeState[1][3];
                    cubeState[1][1] = cubeState[5][3];
                    cubeState[1][3] = cubeState[5][2];
                    cubeState[5][3] = cubeState[3][2];
                    cubeState[5][2] = cubeState[3][0];
                    cubeState[3][2] = temp[0];
                    cubeState[3][0] = temp[1];
                } else {
                    cubeState[4][0] = cubeState[3][2];
                    cubeState[4][1] = cubeState[3][0];
                    cubeState[3][2] = cubeState[5][3];
                    cubeState[3][0] = cubeState[5][2];
                    cubeState[5][3] = cubeState[1][1];
                    cubeState[5][2] = cubeState[1][3];
                    cubeState[1][1] = temp[0];
                    cubeState[1][3] = temp[1];
                }
            } else if (face === 3) { // Left
                temp = [cubeState[4][0], cubeState[4][2]];
                if (clockwise) {
                    cubeState[4][0] = cubeState[2][3];
                    cubeState[4][2] = cubeState[2][1];
                    cubeState[2][3] = cubeState[5][0];
                    cubeState[2][1] = cubeState[5][2];
                    cubeState[5][0] = cubeState[0][0];
                    cubeState[5][2] = cubeState[0][2];
                    cubeState[0][0] = temp[0];
                    cubeState[0][2] = temp[1];
                } else {
                    cubeState[4][0] = cubeState[0][0];
                    cubeState[4][2] = cubeState[0][2];
                    cubeState[0][0] = cubeState[5][0];
                    cubeState[0][2] = cubeState[5][2];
                    cubeState[5][0] = cubeState[2][3];
                    cubeState[5][2] = cubeState[2][1];
                    cubeState[2][3] = temp[0];
                    cubeState[2][1] = temp[1];
                }
            } else if (face === 4) { // Up
                temp = [cubeState[0][0], cubeState[0][1]];
                if (clockwise) {
                    cubeState[0][0] = cubeState[1][0];
                    cubeState[0][1] = cubeState[1][1];
                    cubeState[1][0] = cubeState[2][0];
                    cubeState[1][1] = cubeState[2][1];
                    cubeState[2][0] = cubeState[3][0];
                    cubeState[2][1] = cubeState[3][1];
                    cubeState[3][0] = temp[0];
                    cubeState[3][1] = temp[1];
                } else {
                    cubeState[0][0] = cubeState[3][0];
                    cubeState[0][1] = cubeState[3][1];
                    cubeState[3][0] = cubeState[2][0];
                    cubeState[3][1] = cubeState[2][1];
                    cubeState[2][0] = cubeState[1][0];
                    cubeState[2][1] = cubeState[1][1];
                    cubeState[1][0] = temp[0];
                    cubeState[1][1] = temp[1];
                }
            } else if (face === 5) { // Down
                temp = [cubeState[0][2], cubeState[0][3]];
                if (clockwise) {
                    cubeState[0][2] = cubeState[3][2];
                    cubeState[0][3] = cubeState[3][3];
                    cubeState[3][2] = cubeState[2][2];
                    cubeState[3][3] = cubeState[2][3];
                    cubeState[2][2] = cubeState[1][2];
                    cubeState[2][3] = cubeState[1][3];
                    cubeState[1][2] = temp[0];
                    cubeState[1][3] = temp[1];
                } else {
                    cubeState[0][2] = cubeState[1][2];
                    cubeState[0][3] = cubeState[1][3];
                    cubeState[1][2] = cubeState[2][2];
                    cubeState[1][3] = cubeState[2][3];
                    cubeState[2][2] = cubeState[3][2];
                    cubeState[2][3] = cubeState[3][3];
                    cubeState[3][2] = temp[0];
                    cubeState[3][3] = temp[1];
                }
            }
        }
        
        function performMove(cubeState, move) {
            const faceMap = {'F': 0, 'R': 1, 'B': 2, 'L': 3, 'U': 4, 'D': 5};
            const isPrime = move.includes("'");
            const isDouble = move.includes("2");
            const faceLetter = move[0];
            const faceIndex = faceMap[faceLetter];
            
            if (isDouble) {
                rotateFace(cubeState, faceIndex, true);
                rotateFace(cubeState, faceIndex, true);
            } else {
                rotateFace(cubeState, faceIndex, !isPrime);
            }
        }
        
        // Initial render
        renderFace();
        updateAsciiInput();
    </script>
</body>
</html>
